# 1. HTTP 란?

> 하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol)은 월드 와이드 웹의 토대이며 하이퍼텍스트 링크를 사용하여 웹 페이지를 로드하는 데 사용된다. HTTP는 네트워크 장치 간에 정보를 전송하도록 설계된 애플리케이션 계층 프로토콜이며 네트워크 프로토콜 스택의 다른 계층 위에서 실행된다. HTTP를 통한 일반적인 흐름에는 클라이언트 시스템에서 서버에 요청한 다음 서버에서 응답 메시지를 보내는 작업이 포함된다.

# 2. 프로토콜 스택

![](https://velog.velcdn.com/images/aoleejohn/post/54e20c9f-6db7-48a9-a65e-c4bd64353e65/image.png)

### 2-1. 응용 계층

>HTTP, SMTP(간이 우편 전송 프로토콜), FTP(파일 전송 프로토콜) 등이 해당되며, 송수신측 사이에 주고 받는 서비스에 따라 응용 계층의 프로토콜이 달라진다. 웹 브라우저(클라이언트)가 웹 서버에 요청한 데이터가 HTML 문서라면 HTTP 프로토콜이 사용된다. 그리고 클라이언트가 데이터를 요청할 때는 GET, POST, PATCH, DELETE 등 _**HTTP 메서드**_, 네트워크 상 자원의 위치를 나타내는 정보인 _**URL**_ 그리고 _**사용하는 HTTP 버젼 정보**_와 함께 정보를 요청한다. 그 외에도 클라이언트가 서버에 요청하는 정보가 메일, 파일 등이면 각각 SMTP 프로토콜, FTP 프로토콜이 사용된다.

### 2-2. 전송 계층

> 전송 계층은 데이터 전송의 신뢰성을 보장하기 위한 계층으로, 송신 측에서 수신 측으로 패킷이 정상적으로 전달되었는지 확인하는 역할을 수행한다. 또한 TCP(전송 제어 프로토콜)와 UDP(사용자 데이터그램 프로토콜)로 나뉘며, 각 프로토콜마다 서로 다른 특성을 갖는다.

>
TCP는 신뢰성과 정확성을 추구하는 연결형 통신 프로토콜을 따르기 때문에 신뢰할 수 있는 연결을 위해 3-way 핸드셰이크 과정을 거친다. 이 때 브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송/수신할 경우에는 TCP가 주로 활용된다. 반면 UDP는 효율성을 추구하는 비연결형 통신 프로토콜을 따르므로 핸드셰이킹 과정도 생략된다. 주로 데이터 전송의 정확성보다 신속성이 강조되는 스트리밍 방식의 동영상 서비스에 활용된다. 혹은 DNS 서버에 대한 조회 등 짧은 제어용 데이터를 송/수신할 경우에는 UDP를 쓴다.

> ### 3-way 핸드셰이크
>> TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 말한다.
3way handshake는 양쪽 모두 데이터를 전송할 준비가 되어있다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 다른 한쪽이 준비되었다는 것을 알 수 있도록 해준다.
>
>>#### Flag 정보
TCP Header에는 CONTROL BIT(플래그 비트, 6bit)가 존재하며, 각각의 bit는 "URG-ACK-PSH-RST-SYN-FIN"의 의미를 가진다.
해당 위치의 bit가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다.
- SYN(Synchronize Sequence Number)
연결 설정. Sequence Number를 랜덤으로 설정하여 세션을 연결하는 데 사용하며, 초기에 Sequence Number를 전송한다.
따라서, Connection을 생성할때 사용하는 flag이다.
- ACK(Acknowledgement)
응답 확인. 패킷을 받았다는 것을 의미하는 flag이다.
Acknowledgement Number 필드가 유효한지를 나타낸다.
양단 프로세스가 쉬지 않고 데이터를 전송한다고 가정하면 최초 연결 설정 과정에서 전송되는 첫 번째 세그먼트를 제외한 모든 세그먼트의 ACK 비트는 1로 지정된다고 생각할 수 있다.
- FIN(Finish)
연결 해제. 세션 연결을 종료시킬 때 사용되며, 더 이상 전송할 데이터가 없음을 의미한다.
4way handshake에서 사용한다.

### 2-3. 네트워크 계층

> 이 계층은 데이터를 원하는 목적지로 전송하는 역할을 수행한다. 송/수신 기기 사이에는 라우터란 네트워크 장비가 있는데, 데이터 패킷들이 바로 이들을 거쳐 수신 측으로 전달된다. 라우터는 데이터의 목적지가 정해지면 해당 목적지까지 어떤 경로로 가는 것이 효율적인지 파악한다. 또한 경로를 결정하기 앞서, 원하는 네트워크를 식별하기 위한 목적지의 주소 정보인 IP 주소를 확인하는데, 목적지 IP 주소까지 어떤 경로를 거쳐 데이터를 보낼지 결정하는 것을 라우팅이라고 한다.

### 2-4. 데이터링크 계층

> 송/수신측 사이에 경로가 결정되었으면, 링크 계층은 한 노드에서 인접한 노드로 패킷을 보내기 위한 역할을 한다. 앞서 언급한 계층들을 모두 거친 상태라면, 데이터는 서버의 LAN(건물 안이나 특정 지역을 범위로 하는 지엽적인 네트워크)까지 도착한 것이다. 이제 데이터 링크 계층에서는 네트워크 장비 간에 신호를 주고받는 규칙으로 이더넷을 사용하며, 이는 랜에서 데이터를 정상적으로 주고 받기 위해 필요하다.

### 2-5. 물리 계층

> 컴퓨터와 네트워크 장비를 연결하고 컴퓨터와 네트워크 장비 간에 전송되는 데이터를 전기 신호로 변환하는 계층이다. 기본적으로 네트워크 통신에서는 0과 1만 사용되는데, 컴퓨터 내부에 존재하는 네트워크 장비인 랜 카드는 이러한 비트열을 전기 신호로 변환하는 역할을 수행한다.

# 네트워크 포트

> 어떠한 데이터가 송수신을 할 때 Datalink 계층에서는 호스트의 NIC로 MAC Address를 판별하고 Network 계층에서는 IP Address로 목적지를 판별한다.
이렇게 MAC Address와 IP Address를 통해 목적지 호스트까지 도달한 후에는 어떤 Process(프로세스)에서 데이터를 받을 것인지 를 알아야 하는데 이 때 쓰이는 것이 Port Number(포트 번호)다.

> ## 포트 포워딩
>> 외부에서 공유기 내의 특정한 장치로 접속하기 위해서는 IP Address를 알아야 하지만 공유기 내부의 IP는 사설 IP로 이루어져 있어 외부에서 IP만으로 특정 PC를 지정할 수 없다. 따라서 공유기의 공인 IP로 접속한 후 특정한 PC로 연결되도록 포트 넘버를 공유기에서 정의해주는 작업이 필요하다.

포트 번호|프로토콜|목적
::|::|::
20 또는 21|FTP|파일 전송
22	|SSH|	보안 네트워크 연결
25	|SMTP|	이메일 전송
53	|DNS|	도메인으로 IP 확인
80	|HTTP|	WWW 연결
443	|HTTPS|	보안 WWW 연결
500	|ISAKMP|	IPsec 연결 설정 프로세스
3389	|RDP|	원격 데스크톱 컴퓨터 연결


## 이해한거 정리

>
- 송신
>
> 응용 계층: 인터넷을 사용하는 모든 프로세스에서 사용한다. 어느 프로토콜을 사용할지 결정하고 데이터를 변환, 압축, 암호화한다.// 메세지
>
전송 계층: 응용 계층에서의 데이터를 segment들로 쪼갠다. 쪼개진 segment들을 패킷이라 부르며 각 패킷에는 발신/송신 포트 번호, 데이터 시퀀스 번호, Checksum을 담는다.(Checksum은 데이터 손상/손실을 체크할 때 사용)// 세그먼트
>
네트워크 계층: 전송계층에서의 패킷에 송수신 IP를 추가해주고, 패킷은 IP 주소를 찾아 패킷을 목적지까지 전달해주는 라우터를 통해 전달된다. IP 주소의 앞부분에 해당하는 정확한 네트워크에 먼저 패킷을 전달하고, 이어서 IP 주소의 뒷부분에 해당하는 호스트 (컴퓨터)에 이어서 패킷을 전달한다. // 데이터그램
>
물리 계층: 컴퓨터 간 통신은 0과 1을 활용해 모든 데이터를 전송할 수 있게 된다. 이러한 0과 1의 조합은 전선을 통해 아날로그 신호로 변환돼 (encoding) 목적지에 전달한다.// 프레임

>
- 수신
>
>>각 계층은 데이터 헤드의 해당 계층 프로토콜을 수행하고 나머지 데이터를 상위 계층에 전달한다 생각하면 된다.
>
물리 계층: 목적지에 도착한 신호를 0과 1의 조합으로 해석한다(decoding).
>
네트워크 계층: 목적지 IP를 확인하고 목적지가 아니라면 라우터에서 패킷을 목적지 IP로 송신.
>
전송 계층: 패킷이 정상적으로 전달되었는지 확인하는 역할을 수행한다. 정상적으로 전달 되지 않았다면 다시 유실된 데이터 시퀀스의 재전송을 요청한다. 또한 Flow 컨트롤을 통해 데이터가 전송되는 양을 컨트롤하는 작업을 수행한다(장치별 데이터를 감당할 수 있는 양이 다르기 때문).
>
응용 계층: 최종적으로 데이터를 받게된다.

# 참조

> https://joonfluence.tistory.com/96
https://haeunyah.tistory.com/85
https://better-together.tistory.com/89

=========================================================================


# HTTP Method 란??

> HTTP 메서드란 클라이언트와 서버 사이에 이루어지는 요청(Request)과 응답(Response) 데이터를 전송하는 방식을 이다.

>
### 주요 메소드
- GET : 리소스 조회
- POST:  요청 데이터 처리, 주로 등록에 사용
- PUT : 리소스를 대체(덮어쓰기), 해당 리소스가 없으면 생성
- PATCH : 리소스 부분 변경 (PUT이 전체 변경, PATCH는 일부 변경)
- DELETE : 리소스 삭제
### 기타 메소드
- HEAD : GET과 동일하지만 메시지 부분(body 부분)을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

# Status Code

>서버에서의 처리 결과는 응답 메시지의 상태 라인에 있는 상태 코드(status code)를 보고 파악할 수 있다. 상태 코드는 세 자리 숫자로 되어 있는데 첫 번째 숫자는 HTTP 응답의 종류를 구분하는 데 사용하며 나머지 2개의 숫자는 세부적인 응답 내용 구분을 위한 번호이다.

>
- ### 1XX: Informational(정보 제공)
임시 응답으로 현재 클라이언트의 요청까지는 처리되었으니 계속 진행하라는 의미입니다. HTTP 1.1 버전부터 추가되었습니다.
- ### 2XX: Success(성공)
클라이언트의 요청이 서버에서 성공적으로 처리되었다는 의미입니다.
- ### 3XX: Redirection(리다이렉션)
완전한 처리를 위해서 추가 동작이 필요한 경우입니다. 주로 서버의 주소 또는 요청한 URI의 웹 문서가 이동되었으니 그 주소로 다시 시도하라는 의미입니다.
- ### 4XX: Client Error(클라이언트 에러)
없는 페이지를 요청하는 등 클라이언트의 요청 메시지 내용이 잘못된 경우를 의미합니다.
- ### 5XX: Server Error(서버 에러)
서버 사정으로 메시지 처리에 문제가 발생한 경우입니다. 서버의 부하, DB 처리 과정 오류, 서버에서 익셉션이 발생하는 경우를 의미합니다.

# 참조 
>https://inpa.tistory.com/entry/WEB-🌐-HTTP-메서드-종류-통신-과정-💯-총정리
https://hongong.hanbit.co.kr/http-상태-코드-표-1xx-5xx-전체-요약-정리/


=========================================================================

# Rest API 란 ??

>REST(RESTful, Representational State Transfer, RESTful, 레스트풀) API는 REST 아키텍처 스타일의 제약 조건을 준수하고 RESTful 웹 서비스와 상호 작용할 수 있도록 하는 애플리케이션 프로그래밍 인터페이스(API 또는 웹 API)이다.

# API(Application Programming Interface)란?
>API는 애플리케이션 소프트웨어를 구축하고 통합하기 위한 정의 및 프로토콜 세트로, 때때로 API는 정보 제공자와 정보 사용자 간의 계약으로 지칭되며 소비자에게 필요한 콘텐츠(호출)와 생산자에게 필요한 콘텐츠(응답)를 구성한다.예를 들어, 날씨 서비스용 API 설계에서는 사용자는 우편번호를 제공하고, 생산자는 두 부분(첫 번째는 최고 기온, 두 번째는 최저 기온)으로 구성된 응답으로 답하도록 지정할 수 있다.

>바꿔 말하자면 컴퓨터나 시스템과 상호 작용하여 정보를 검색하거나 기능을 수행하고자 할 때 API는 사용자가 원하는 것을 시스템에 전달할 수 있게 지원하여 시스템이 이 요청을 이해하고 이행하도록 할 수 있다. 

>API를 사용자 또는 클라이언트, 그리고 사용자와 클라이언트가 얻으려 하는 리소스 또는 웹 서비스 사이의 조정자로 생각하면 된다. API는 조직이 보안, 제어, 인증을 유지 관리(누가 무엇에 액세스할 수 있는지 결정)하면서 리소스와 정보를 공유할 수 있는 방법이기도 하다. 

>API의 또 다른 장점은 캐싱, 즉 리소스 검색 방법 또는 리소스의 출처에 대해 자세히 알 필요가 없다는 것이다.

# Rest ?? 

> 헤더와 매개 변수는 요청의 메타데이터, 권한 부여, URI(Uniform Resource Identifier), 캐싱, 쿠키 등에 대한 중요한 식별자 정보를 포함하고 있기 때문에 RESTful API HTTP 요청의 HTTP 메서드에서도 중요하다는 점을 유의해야 한다. 요청 헤더와 응답 헤더가 있으며, 각각 고유한 HTTP 연결 정보 및 상태 코드가 있다.

>- 자원(Resource) 중심: REST API는 자원을 중심으로 설계된다. 자원은 HTTP URI로 표현되며, 자원에 대한 CRUD(Create, Read, Update, Delete) 작업을 수행할 수 있다.
- 상태 없음(Stateless): REST API는 상태를 유지하지 않는다. 즉, 클라이언트가 API를 호출할 때마다 서버는 이전 요청과는 무관하게 해당 요청을 처리한다.
- 캐싱 가능(Cacheable): REST API는 캐싱이 가능합니다. 클라이언트는 이전 요청의 응답을 캐시하여 서버에 대한 요청 수를 줄일 수 있다.
- 계층화 가능(Layered): REST API는 계층화 가능하다. API는 여러 계층으로 구성될 수 있으며, 각 계층은 다른 역할을 수행할 수 있다.

=========================================================================

# 쿠키

>웹브라우저에서 쿠키(Cookie)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각으로, key=value 형식의 문자열 데이터 묶음이다.
브라우저는 이 문자열 데이터 조각들을 저장해놓았다가 동일한 서버에 재요청시 쿠키 데이터를 전송할 수 있다.
>
HTTP 프로토콜은 기본적으로 무상태성을 가지고 있기 때문에
서버와 클라이언트 간의 연결 유지를 구현하기 위해 서로를 인식할 수 있는 식별데이터가 쿠키 데이터 조각이라고 생각하면 된다.


> ### 주요 사용처
- 세션관리
서버에 저장해야할 로그인, 장바구니, 게임 스코어 등의 정보 관리
ex) 로그인 유지, 장바구니에 담은 제품 유지 등
- 개인화
사용자 선호, 테마 등 사용자의 개인 세팅을 저장, 관리
ex) 다크모드 사용, 언어설정, 메뉴 순서 최적화 등
- 트래킹
분석 및 광고 개제를 위해 웹사이트 내 사용자 행동 기록, 관리
ex) 분석데이터 수집, 리타게팅 광고에 기여 등

> ### 쿠키 인증 방식
1. 브라우저(클라이언트)가 서버에 요청을 보낸다.
2. 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담는다.
3. 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보낸다.

> ## 단점
- 요청시 쿠키의 값을 그대로 보내기 때문에 유출, 조작 당할 위험존재하기 때문에 보안에 취약
- 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없다.
- 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 공유 불가능
- 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.

# 세션

> 
쿠키의 단점을 해결하기 위해서 세션은 비밀번호, 카드번호 등의 중요한 정보는 서버측에서 관리하는 방식이다.

> - 클라이언트는 세션Id를 쿠키를 통해서 기억한다.
- 브라우저에 세션Id를 저장해둔 클라이언트는 다음 요청때마다
헤더의 cookie에 세션Id를 담아서 전송한다.
- 서버는 클라이언트가 보낸 요청의 쿠키에 담긴 세션Id와,
세션 스토리지에 담긴 세션Id를 대조해 인증상태를 판단하는 것이다.
(즉, 세션은 쿠키를 기반으로 한다.)

> ### 세션 인증 방식
1. 사용자가 로그인을 요청
2. 서버에서 계정 정보를 읽어 사용자를 확인, 사용자의 고유한 Id를 부여하여 세션 저장소에 저장한후, 이와 연결된 세션Id를 발급한다.
3. 사용자는 서버에서 해당 세션Id를 받아 쿠키에 저장한 후, 인증이 필요한 요청마다 쿠키를 헤더에 실어 보낸다.
4. 서버는 쿠키를 받아 세션 저장소에서 대조 후 대응되는 정보를 가져온다.
5. 인증이 완료되면 서버는 사용자에 맞는 데이터를 보내준다.

> ## 단점
키를 포함한 요청이 외부에 노출되더라도 세션Id 자체에는 유의미한 개인정보를 담고있지 않다.
그러나, 탈취자가 세션Id 자체를 탈취하여 클라이언트인척 위장할 수 있다는 한계가 있다. 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다.

# 토큰

>토큰 인증은 클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에게
인증되었다는 의미로 '토큰'을 부여한다.
이 토큰은 유일하며, 토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다.
그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증과정을 처리
기존의 세션 인증은 서버가 파일이나 데이터베이스에 세션정보를 가지고 있어야 하고, 이를 조회하는 과정이 필요하기 때문에 많은 오버헤드가 발생했다.
하지만, 토큰은 그와 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.
토큰 자체에 데이터가 들어있기 때문에 클라이언트에서 받아 위조되었는지 판별만 하면 되기 때문이다.

 
> ### 토큰 인증 방식
1. 사용자가 아이디와 비밀번호로 로그인을 한다.
2. 서버측에서 사용자에게 유일한 토큰을 발급한다.
3. 클라이언트는 서버측에서 전달받은 토큰을 쿠키나 스토리지에 저장해두고, 서버에 요청을 할 때마다 해당 토큰을 HTTP요청 헤더에 포함시켜 전달한다.
4. 서버는 전달받은 토큰을 검증하고 요청에 응답한다.
   토큰에는 요청한 사람의 정보가 담겨있어서 서버는 DB를 조회하지않고 누가 요청했는지 알 수 있다.

> ## 단점
쿠키 / 세션과 다르게 토큰 자체의 데이터 길이가 길어서,
인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
Payload 자체는 조회가 가능하기 때문에 유저의 중요한 정보를 담을 수 없다.
토큰은 발급하면 만료될 때까지 계속 사용이 가능하기 때문에
토큰이 탈취당하면 대처하기가 어렵다.

# JWT

> JWT (JSON Web Token)은 인증에 필요한 정보들을 암호화시킨 JSON 토큰을 의미한다. 세션 / 쿠키와 함께 가장 대표적인 인증 수단이다.
JWT 기반인증은 JWT 토큰을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식이다.
JWT는 JSON 데이터를 Base64 URL-safe-Encode 를 통해 인코딩을 직렬화 한것이며, 토큰 내부에는 위.변조 방지를 위해 개인키를 통한 전자서명도 들어가있다.
따라서 사용자가 JWT를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치고 검증이 완료되면 요청한 응답을 돌려준다.

![](https://velog.velcdn.com/images/aoleejohn/post/81ce718d-aea8-4f9a-b558-7974bdbce3aa/image.png)

>
Header는 JWT에서 사용할 타입과 해시 알고리즘의 종류가 담겨있으며,
Payload는 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨있고,
Payload에는 해독이 가능하기 때문에 중요한 정보는 포함해서는 안된다.
Signature에는 Header, Payload를 Base64 URL-safe Encode를 한 이후
Header에 명시된 해시함수를 적용하고, 개인키로 서명한 전자서명이 담겨있다.

> ### JWT 인증 과정
1. 사용자가 로그인을 한다.
2. 서버에서는 계정 정보를 읽어 사용자를 확인 후, 사용자 고유ID값을 부여한 후,
기타 정보와 함께 Payload에 넣는다.
3. JWT의 유효기간 설정
4. 암호화할 SECRET KEY를 이용하여 Access Token을 발급 한다.
5. 사용자는 Access Token을 받아 로컬 스토리지(혹은 쿠키)에
    저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어서 보낸다.
6. 서버에서는 해당 토큰의 Verify Signature을 SECRET KEY로 복호화한 후,
    조작여부, 유효기간을 확인한다.
7. 검증이 완료되면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.

> ### JWT 장점
Header와 Payload를 가지고 Signature를 생성하여 데이터 위.변조를 막을 수 있다.
인증 정보에 대한 별도의 저장소가 필요없다.
토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다.
(Facebook로그인, Goggle로그인 등이 모두 토큰을 기반으로 인증)
JWT는 발급한 후 검증만 하면 되기 때문에 Stateless한 서버를 만드는 입장에선 아주 큰 장점이다.

> ## JWT 단점
이미 발급된 JWT에 대해서는 돌이킬 수 없다.  세션 / 쿠키의 경우 만일 쿠키가 악의적으로 이용되고 있다면,
해당하는 세션을 지워버리면 된다.
하지만 JWT는 한번 발급되면 유효기간이 완료될 때까지 계속 사용이 가능하다.
따라서 악의적인 사용자는 유효기간이 지나기 전까지 정보를 털어갈 수 있다.
Payload의 정보가 제한적이다. Payload는 암호화 되지않기 때문에 디코딩하면 누구나 정보를 확인할 수 있다.
따라서 유저의 중요한 정보들은 Payload에 넣을 수 없다.
인증이 필요한 요청이 많아질수록 서버의 자원 낭비가 발생한다.

> ## 개선을 위한 Refresh Token !!
JWT의 단점을 해결하기 위해 Access Token, Refresh Token으로 이중으로 나누어 인증을 한다.
유효기간을 짧게 하면서 더 좋은 방법으로 나온게 Refresh Token인 것이다.
처음에 로그인했을 때 Access Token과 동시에 발급되는 Refresh Token은 긴 유효기간을 가지면서,
Access Token이 만료됐을 때 새로 발급해주는 열쇠가 된다.
즉, Access Token의 유효기간을 짧게 만들고, 유효기간이 만료될 때마다 Refresh Token을 통해 새로운 Access Token을 만들어서 보안을 조금이라도 더 안전하게 한것이다.

> ### Refresh Token 사용하는 과정
1. 사용자가 ID, PW를 통해 로그인
2. 서버에서는 회원 DB에서 값을 비교한다. (보통 PW는 암호화해서 들어간다.)
3. 사용자 인증이 되면 서버에서 Access Token, Refresh Token을 발급, 보통 회원 DB에 Refresh Token을 저장
4. 서버는 사용자에게 Access Token, Refresh Token을 보낸다.
5. 사용자는 Refresh Token을 안전한 저장소에 저장 후, Access Token을 헤더에 실어 요청을 보낸다.
6. 서버는 Access Token을 검증 후
7. 이에 맞는 데이터를 사용자에게 보내준다.
8. 시간이 흘러 Access Token이 만료
9. 사용자는 만료된 Access Token을 헤더에 실어 요청을 보낸다.
10. 서버는 Access Token이 만료됐음을 확인
11. 만료된 토큰임을 알리고 권한없음을 신호로 보낸다.
     Access Token이 만료될때 마다 9~11 과정을 거칠 필요는 없다.
     Access Token의 Payload를 통해 유효기간을 알 수 있다.
     따라서 프론트엔드 단에서 API 요청전에 토큰이 만료 됐다면 바로 재발급 요청 가능
12. 사용자는 Refresh Token 과 Access Token을 함께 서버로 보낸다.
13. 서버는 받은 Access Token이 조작되지 않았는지 확인하고,
      Refresh Token과 사용자의 DB에 저장되어 있던 Refresh Token을 비교한다.
14. 서버는 Refresh Token이 동일하고 유효기간도 지나지 않았다면 Access Token을 사용자에게 보내준다.
15. 새로운 Access Token을 헤더에 실어 API 요청을 한다.

# 참조

>https://jhbljs92.tistory.com/entry/1-JWT-%ED%86%A0%ED%81%B0-%EC%9D%B8%EC%A6%9D%EA%B3%BC-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%ED%86%A0%ED%81%B0

=========================================================================


# MVC 란 ???

>MVC 패턴은 Model, View, Controller의 줄임말로써, 사용자와 상호작용하는 S/W를 디자인함에 있어 세가지 요소로 쪼갠 디자인 패턴이다.
디자인 패턴이란 프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용해서 쓸 수 있는 것을 정리하여 특정한 "규약"을 통해 쉽게 쓸 수 있는 형태로 만든 것을 말한다.

> ### 사용 목적
MVC 패턴의 사용 목적은 서로 분리되어 각자의 역할에 집중할 수 있게끔하여 개발을 하고 그렇게 애플리케이션을 만든다면, 유지보수성, 애플리케이션의 확장성, 그리고 유연성이 증가하고, 중복코딩이라는 문제점 또한 사라지게 되기 때문이다.

>- ### Model
> 애플리케이션의 정보, 데이터의 가공을 책임지며 DB와 상호작용하며 비즈니스 로직을 처리하는 모듈, 컴포넌트를 말한다.
Model은 사용자가 이용하려는 모든 데이터를 가지고 있어야 하며, View(뷰) 또는 Controller(컨트롤러)에 대해 어떤 정보도 알 수 없어야 한다. 또한 변경이 일어나면 처리 방법을 구현해야 한다.
>
>
> - ### View
> 사용자 인터페이스 요소를 뜻하는데, Client에게 보여지는 결과화면을 반환하는 모듈을 말한다.
Model(모델)이 가지고 있는 데이터를 저장하면 안되고, Model(모델)이나 Controller(컨트롤러)에 대한 정보를 알면 안되며 단순히 표시해주는 역할만 해야 한다. 변경이 일어나면 처리 방법을 구현해야 한다.
> 
>
> - ### Controller
>Client 요청이 들어왔을 때 그 입력을 처리하고 어떤 로직을 실행시킬 것인지 Model(모델)과 View(뷰)를 연결해주며 제어하는 모듈을 말한다.
>Model(모델) 또는 View(뷰)에 대한 정보를 알아야 한다. Model(모델) 또는 View(뷰)의 변경을 인지하여 대처를 해야한다.


> ## MVC1
![](https://velog.velcdn.com/images/aoleejohn/post/1abe617f-dd1b-4509-8ba6-dc6e619e43ed/image.png)
>
MVC1은 WAS(Web Application Server)에서 모든 파일에 클라이언트가 요청한 로직을 처리하는 경우다.
JSP(Java Server Page)에서 View, Controller의 역할을 담당하며 그 결과를 클라이언트에게 반환한다.
MVC1은 아키텍처가 간단하고 JSP에 거의 모든 로직을 집어넣기 때문에 작은 웹 어플리케이션을 제작할 때는 큰 무리가 없지만 대규모 웹 어플리케이션을 제작하게 될 시 유지보수에 큰 어려움이 따른다.

> ## MVC2
>![](https://velog.velcdn.com/images/aoleejohn/post/33e6fa06-bb3c-4707-a647-a05045a5eff6/image.png)
>
>MVC2는 이 MVC1방식을 보완한 아키텍처다.
MVC 패턴에 맞게 Model, Controller, View 부분로 모듈화 됐고 JSP는 로직 처리가 없이 단순히 Client에게 보여지는 뷰만을 담당한다.
이 방식은 각각이 모듈화되어 있어 유지보수가 매우 쉬워지는 큰 장점이 있다.
현재의 웹 어플리케이션은 거의 MVC2방식을 따른다 보면 된다.

# Web 서버 란 ??

> ### 하드웨어 측면
웹 서버의 소프트웨어와 website의 컴포넌트 파일들을 저장하는 컴퓨터이다. (컴포넌트 파일에는 HTML 문서, images, CSS stylesheets, 그리고 JavaScript files가 있다.) 웹 서버는 인터넷에 연결되어 웹에 연결된 다른 기기들이 웹 서버의 데이터(컴포넌트 파일들)를 주고받을 수 있도록 한다.
>
### 소프트웨어 측면
소프트웨어 측면에서, 웹 서버는 기본적으로 웹 사용자가 어떻게 호스트 파일들에 접근하는지를 관리한다. HTTP 서버는 URL(Web addresses)과 HTTP(당신의 브라우저가 웹 페이지를 보여주기 위해 사용하는 프로토콜)의 소프트웨어 일부이다.

> Web 서버는 정적인 데이터, 즉 HTML 문서, images, CSS stylesheets, 그리고 JavaScript files과 같은 데이터를 처리할 때 사용한다.

> 대표적으로 아파치서버가 있다.

# WAS(Web Application Server) 란 ???

> 동적 서버 콘텐츠를 수행하는 것으로 일반적인 웹 서버와 수별이 되며, 주로 데이터 베이스 서버와 같이 수행된다. WAS에서도 정적인 데이터를 처리해 줄 수 있지만, 단순 정적 데이터들만을 처리할 것이면 Web 서버를 사용하는 편이 빠르고 안정적이다. 또한 정적, 동적인 데이터를 동시에 요구하게 된다면 WAS하나로도 처리가 가능하지만 다음과 같은 이유들로 Web 서버와 WAS를 분리하는 것이 좋다.
- 서버 부하 방지
WAS와 웹 서버는 분리하여 서버의 부하를 방지해야 한다. WAS는 DB 조회나 다양한 로직을 처리하고, 단순한 정적 컨텐츠는 웹 서버에서 처리해줘야 한다. 만약 정적 컨텐츠까지 WAS가 처리한다면 부하가 커지게 되고, 수행 속도가 느려질 것이다. 
- 보안 강화
SSL에 대한 암호화, 복호화 처리에 웹 서버를 사용 가능
- 여러 대의 WAS 연결 가능
로드 밸런싱을 위해 웹 서버를 사용할 수 있다. 여러 개의 서버를 사용하는 대용량 웹 어플리케이션의 경우 웹 서버와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다. 
- 여러 웹 어플리케이션 서비스 가능
하나의 서버에서 PHP, JAVA 애플리케이션을 함께 사용할 수 있다. 

> ### 웹 컨테이너
> JSP와 Servlet을 실행시킬 수 있는 소프트웨어를 웹 컨테이너 혹은 서블릿 컨테이너라 한다. 웹 서버에서 JSP를 요청하면 톰캣에서 JSP파일을 서블릿 파일로 변환하여 컴파일을 수행하고, 서블릿 수행결과를 웹서버에 전달해 준다.

> 대표적으로 tomcat이 있다.


![](https://velog.velcdn.com/images/aoleejohn/post/f7657528-e872-4c8f-abfc-b9920459cf34/image.png)


# JSP 란 ???

>JSP 란 JavaServer Pages 의 약자이며 HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구이다.
JSP 가 실행되면 자바 서블릿(Servlet) 으로 변환되며 웹 어플리케이션 서버에서 동작되면서 필요한 기능을 수행하고 그렇게 생성된 데이터를 웹페이지와 함께 클라이언트로 응답한다.

> 간단하게 html안에 java가 있다는 느낌


# Servlet 이란 ??

> 서블릿이란 웹페이지를 동적으로 생성하기 위해 서버측 프로그램을 말한다. 
이는 자바 언어를 기반으로 만들지며 웹 어플리케이션 서버 ( Web Application Sever ) 위에서 컴파일 되고 동작한다.

> java안에 html이 있는 느낌

# Javabean 이란???

>JSP에서 객체를 가져오기 위한 기법으로 데이터 전달 오브젝트 파일 DTO(Data Transfer Object)라고도 한다.
자바로 작성된 컴포넌트들 즉, 클래스(Class)를 일반적으로 말한다.
JSP 프로그래밍에는 DTO(Data Transfer Object)나 DAO(Data Access Object)클래스의 객체를 JSP페이지에서 사용하기 위해 사용한다.

> ### 사용 목적
JSP 페이지가 화면 표현 부분과 로직들이 같이 존재하여 복잡한 구성을 가급적 피하고, JSP 페이지의 로직 부분을 분리해서 코드를 재사용함으로써 프로그램의 효율을 높이기 위해서 사용한다.


# 참조
> https://code-lab1.tistory.com/199
https://helloworld-88.tistory.com/71
https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/What_is_a_web_server

=========================================================================


# HTTPS 란??

> HTTP + TLS => HTTPS !!

> 하이퍼텍스트 전송 프로토콜 보안(HTTPS)은 웹 브라우저와 웹 사이트 간에 데이터를 전송하는 데 사용되는 기본 프로토콜인 HTTP의 보안 버전이다. HTTPS는 데이터 전송의 보안을 강화하기 위해 암호화된다. 이는 사용자가 은행 계좌, 이메일 서비스, 의료 보험 공급자에 로그인하는 등 중요한 데이터를 전송할 때 특히 중요하다.
모든 웹 사이트, 특히 로그인 자격 증명이 필요한 웹 사이트는 HTTPS를 사용해야 한다. 크롬 등 최신 웹 브라우저에서는 HTTPS를 사용하지 않는 웹 사이트가 HTTPS를 사용하는 웹 사이트와 다르게 표시된다.

# HTTPS 작동 과정

>HTTPS는 암호화 프로토콜을 사용하여 통신을 암호화한다. 이 프로토콜은 이전에는 보안 소켓 계층(SSL)으로 알려졌지만, 전송 계층 보안(TLS)이라고 불린다. 이 프로토콜은 비대칭 공개 키 인프라로 알려진 것을 사용하여 통신을 보호합한다. 이 유형의 보안 시스템에서는 두 개의 서로 다른 키를 사용하여 두 당사자 간의 통신을 암호화한다.
>
- ### 개인 키
이 키는 웹 사이트 소유자가 관리하며, 독자께서 짐작할 수 있듯이 비공개로 유지됩니다. 이 키는 웹 서버에 있으며 공개 키로 암호화된 정보를 해독하는 데 사용됩니다.
- ### 공개 키
이 키는 안전한 방식으로 서버와 상호 작용하고자 하는 모든 사람이 사용할 수 있습니다. 공개 키로 암호화된 정보는 개인 키로만 해독할 수 있습니다.

>클라이언트가 서버에 데이터를 보낼 때는 공개키로 암호화하지만, 반대의 경우에는 서버가 클라이언트에 데이터를 보낼 때는 세션 키를 사용한다. 세션 키는 클라이언트와 서버가 암호화된 통신을 시작하기 전에 협의하여 생성하는 키이다. 클라이언트와 서버는 모두 세션 키를 공유하고, 이 키를 사용하여 데이터를 암호화하고 복호화한다. 세션 키는 클라이언트와 서버가 통신하는 동안만 유효하기 때문에 통신이 끝나면 세션 키는 삭제된다.

# TLS/SSL 란 ??

> ### TLS
전송 계층 보안(TLS)은 인터넷 상의 커뮤니케이션을 위한 개인 정보와 데이터 보안을 용이하게 하기 위해 설계되어 널리 채택된 보안 프로토콜이다. TLS의 주요 사용 사례는 웹 사이트를 로드하는 웹 브라우저와 같이 웹 응용 프로그램과 서버 간의 커뮤니케이션을 암호화하는 것이다. TLS는 또한 이메일, 메시지, 보이스오버 IP(VoIP) 등 다른 커뮤니케이션을 암호화하기 위해 사용된다.

> ### SSL
Netscape가 개발한 SSL(Secure Sockets Layer)이라고 불리는 이전의 암호화 프로토콜에서 발전한 것이 TLS이다. TLS 버전 1.0은 SSL 버전 3.1로서 개발을 시작했지만 Netscape와 더 이상 연관이 없음을 명시하기 위해 발표 전에 프로토콜의 이름이 변경된것이다. 

# TLS 핸드셰이크 란 ??

![](https://velog.velcdn.com/images/aoleejohn/post/f6bd121b-3ee7-46f3-a206-137bbcc71cea/image.png)


>TLS 핸드셰이크는 TLS 암호화를 사용하는 통신 세션을 실행하는 프로세스이다. TLS 핸드셰이크 중에, 통신하는 양측에서는 메시지를 교환하여 서로를 인식하고 서로를 검증하며 사용할 암호화 알고리즘을 구성하고 세션 키에 합의한다.

>TLS 핸드셰이크는 사용자가 HTTPS를 통해 웹 사이트를 탐색하고 브라우저가 처음 해당 웹 사이트의 원본 서버를 쿼리하기 시작할 때마다 발생한다. 다른 통신이 API 호출 및 HTTPS를 통한 DNS 쿼리를 포함하는 HTTPS를 사용할 때에도 매번 TLS 핸드셰이크가 발생한다.

>
TLS 핸드셰이크는 TCP 연결이 TCP 핸드셰이크를 통해 열린 후에 발생합니다.

> ### 진행 과정
1. '클라이언트 헬로' 메시지: 클라이언트가 서버로 "헬로" 메시지를 전송하면서 핸드셰이크를 개시한다. 이 메시지에는 클라이언트가 지원하는 TLS 버전, 지원되는 암호 제품군, 그리고 "클라이언트 무작위"라고 하는 무작위 바이트 문자열이 포함된다.
2. '서버 헬로' 메시지: 클라이언트 헬로 메시지에 대한 응답으로 서버가 서버의 SSL 인증서, 서버에서 선택한 암호 제품군, 그리고 서버에서 생성한 또 다른 무작위 바이트 문자열인 "서버 무작위"를 포함하는 메시지를 전송한다.
3. 인증: 클라이언트가 서버의 SSL 인증서를 인증서 발행 기관을 통해 검증한다. 이를 통해 서버가 인증서에 명시된 서버인지, 그리고 클라이언트가 상호작용 중인 서버가 실제 해당 도메인의 소유자인지를 확인한다.
4. 예비 마스터 암호: 클라이언트가 "예비 마스터 암호"라고 하는 무작위 바이트 문자열을 하나 더 전송한다. 예비 마스터 암호는 공개 키로 암호화되어 있으며, 서버가 개인 키로만 해독할 수 있다. (클라이언트는 서버의 SSL 인증서를 통해 공개 키를 받는다.)
5. 개인 키 사용: 서버가 예비 마스터 암호를 해독한다.
6. 세션 키 생성: 클라이언트와 서버가 모두 클라이언트 무작위, 서버 무작위, 예비 마스터 암호를 이용해 세션 키를 생성한다. 모두 같은 결과가 나와야 한다.
7. 클라이언트 준비 완료: 클라이언트가 세션 키로 암호화된 "완료" 메시지를 전송한다.
8. 서버 준비 완료: 서버가 세션 키로 암호화된 "완료" 메시지를 전송한다.
9. 안전한 대칭 암호화 성공: 핸드셰이크가 완료되고, 세션 키를 이용해 통신이 계속 진행된다.

# HTTP 와 무엇이 다른가??

>엄밀히 말하면 HTTPS는 HTTP와 별개의 프로토콜이 아니다. HTTPS는 단순히 HTTP 프로토콜을 통해 TLS/SSL 암호화를 사용하는 것이다. HTTPS는 특정 공급자가 주장하는 실체가 맞는지 확인하는 TLS/SSL 인증서의 전송을 기반으로 이루어진다.
사용자가 웹 페이지에 연결하면 웹 페이지에서 보안 세션을 시작하는 데 필요한 공개키가 포함된 SSL 인증서를 전송한다. 그런 다음 두 컴퓨터, 즉 클라이언트와 서버가 보안 연결을 설정하는 데 사용되는 일련의 주고받는 통신인 SSL/TLS 핸드셰이크라는 프로세스를 거친다.


# 참조

> https://www.cloudflare.com/ko-kr/learning/ssl/what-is-https/
